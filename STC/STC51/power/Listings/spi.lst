C51 COMPILER V9.60.7.0   SPI                                                               02/08/2023 19:28:49 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE SPI
OBJECT MODULE PLACED IN .\Objects\spi.obj
COMPILER INVOKED BY: E:\software\keil5_v5\C51\BIN\C51.EXE spi.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\List
                    -ings\spi.lst) TABS(2) OBJECT(.\Objects\spi.obj)

line level    source

   1          #include "spi.h"
   2          //#include "ascll.h"
   3          #include "string.h"
   4          
   5          void delay_1ms()    //@24.000MHz
   6          {
   7   1        unsigned char i, j;
   8   1      
   9   1        i = 24;
  10   1        j = 85;
  11   1        do
  12   1        {
  13   2          while (--j);
  14   2        } while (--i);
  15   1      }
  16          
  17          void delay_ms(uint16_t i)
  18          {
  19   1        while(i--)
  20   1          delay_1ms();
  21   1      }
  22          
  23          void LCD_Writ_Bus(uint8_t dat) 
  24          { 
  25   1        uint8_t i;
  26   1        CS=0;
  27   1        for(i=0;i<8;i++)
  28   1        {       
  29   2          SCL=0;
  30   2          if(dat&0x80)
  31   2          {
  32   3             SDA=1;
  33   3          }
  34   2          else
  35   2          {
  36   3             SDA=0;
  37   3          }
  38   2          SCL=1;
  39   2          dat<<=1;
  40   2        } 
  41   1        CS=1; 
  42   1      }
  43          
  44          void LCD_WR_DATA8(uint8_t dat)
  45          {
  46   1        LCD_Writ_Bus(dat);
  47   1      }
  48          
  49          void LCD_WR_DATA(uint16_t dat)
  50          {
  51   1        LCD_Writ_Bus(dat>>8);
  52   1        LCD_Writ_Bus(dat);
  53   1      }
  54          
C51 COMPILER V9.60.7.0   SPI                                                               02/08/2023 19:28:49 PAGE 2   

  55          void LCD_WR_REG(uint8_t dat)
  56          {
  57   1        DC=0;//写命令
  58   1        LCD_Writ_Bus(dat);
  59   1        DC=1;//写数据
  60   1      }
  61          
  62          void LCD_Address_Set(uint16_t x1,uint16_t y1,uint16_t x2,uint16_t y2)
  63          {
  64   1        if(USE_HORIZONTAL==0)
  65   1        {
  66   2          LCD_WR_REG(0x2a);//列地址设置
  67   2          LCD_WR_DATA(x1+26);
  68   2          LCD_WR_DATA(x2+26);
  69   2          LCD_WR_REG(0x2b);//行地址设置
  70   2          LCD_WR_DATA(y1+1);
  71   2          LCD_WR_DATA(y2+1);
  72   2          LCD_WR_REG(0x2c);//储存器写
  73   2        }
  74   1        else if(USE_HORIZONTAL==1)
  75   1        {
  76   2          LCD_WR_REG(0x2a);//列地址设置
  77   2          LCD_WR_DATA(x1+26);
  78   2          LCD_WR_DATA(x2+26);
  79   2          LCD_WR_REG(0x2b);//行地址设置
  80   2          LCD_WR_DATA(y1+1);
  81   2          LCD_WR_DATA(y2+1);
  82   2          LCD_WR_REG(0x2c);//储存器写
  83   2        }
  84   1        else if(USE_HORIZONTAL==2)
  85   1        {
  86   2          LCD_WR_REG(0x2a);//列地址设置
  87   2          LCD_WR_DATA(x1+1);
  88   2          LCD_WR_DATA(x2+1);
  89   2          LCD_WR_REG(0x2b);//行地址设置
  90   2          LCD_WR_DATA(y1+26);
  91   2          LCD_WR_DATA(y2+26);
  92   2          LCD_WR_REG(0x2c);//储存器写
  93   2        }
  94   1        else
  95   1        {
  96   2          LCD_WR_REG(0x2a);//列地址设置
  97   2          LCD_WR_DATA(x1+1);
  98   2          LCD_WR_DATA(x2+1);
  99   2          LCD_WR_REG(0x2b);//行地址设置
 100   2          LCD_WR_DATA(y1+26);
 101   2          LCD_WR_DATA(y2+26);
 102   2          LCD_WR_REG(0x2c);//储存器写
 103   2        }
 104   1      }
 105          
 106          void LCD_Init(void)
 107          {
 108   1        RESET=0;;//复位
 109   1        delay_ms(100);
 110   1        RESET=1;
 111   1        delay_ms(100);
 112   1        
 113   1        BLK=1;
 114   1        delay_ms(100);
 115   1        
 116   1        LCD_WR_REG(0x11);     //Sleep out
C51 COMPILER V9.60.7.0   SPI                                                               02/08/2023 19:28:49 PAGE 3   

 117   1        delay_ms(120);                //Delay 120ms
 118   1        LCD_WR_REG(0xB1);     //Normal mode
 119   1        LCD_WR_DATA8(0x05);   
 120   1        LCD_WR_DATA8(0x3C);   
 121   1        LCD_WR_DATA8(0x3C);   
 122   1        LCD_WR_REG(0xB2);     //Idle mode
 123   1        LCD_WR_DATA8(0x05);   
 124   1        LCD_WR_DATA8(0x3C);   
 125   1        LCD_WR_DATA8(0x3C);   
 126   1        LCD_WR_REG(0xB3);     //Partial mode
 127   1        LCD_WR_DATA8(0x05);   
 128   1        LCD_WR_DATA8(0x3C);   
 129   1        LCD_WR_DATA8(0x3C);   
 130   1        LCD_WR_DATA8(0x05);   
 131   1        LCD_WR_DATA8(0x3C);   
 132   1        LCD_WR_DATA8(0x3C);   
 133   1        LCD_WR_REG(0xB4);     //Dot inversion
 134   1        LCD_WR_DATA8(0x03);   
 135   1        LCD_WR_REG(0xC0);     //AVDD GVDD
 136   1        LCD_WR_DATA8(0xAB);   
 137   1        LCD_WR_DATA8(0x0B);   
 138   1        LCD_WR_DATA8(0x04);   
 139   1        LCD_WR_REG(0xC1);     //VGH VGL
 140   1        LCD_WR_DATA8(0xC5);   //C0
 141   1        LCD_WR_REG(0xC2);     //Normal Mode
 142   1        LCD_WR_DATA8(0x0D);   
 143   1        LCD_WR_DATA8(0x00);   
 144   1        LCD_WR_REG(0xC3);     //Idle
 145   1        LCD_WR_DATA8(0x8D);   
 146   1        LCD_WR_DATA8(0x6A);   
 147   1        LCD_WR_REG(0xC4);     //Partial+Full
 148   1        LCD_WR_DATA8(0x8D);   
 149   1        LCD_WR_DATA8(0xEE);   
 150   1        LCD_WR_REG(0xC5);     //VCOM
 151   1        LCD_WR_DATA8(0x0F);   
 152   1        LCD_WR_REG(0xE0);     //positive gamma
 153   1        LCD_WR_DATA8(0x07);   
 154   1        LCD_WR_DATA8(0x0E);   
 155   1        LCD_WR_DATA8(0x08);   
 156   1        LCD_WR_DATA8(0x07);   
 157   1        LCD_WR_DATA8(0x10);   
 158   1        LCD_WR_DATA8(0x07);   
 159   1        LCD_WR_DATA8(0x02);   
 160   1        LCD_WR_DATA8(0x07);   
 161   1        LCD_WR_DATA8(0x09);   
 162   1        LCD_WR_DATA8(0x0F);   
 163   1        LCD_WR_DATA8(0x25);   
 164   1        LCD_WR_DATA8(0x36);   
 165   1        LCD_WR_DATA8(0x00);   
 166   1        LCD_WR_DATA8(0x08);   
 167   1        LCD_WR_DATA8(0x04);   
 168   1        LCD_WR_DATA8(0x10);   
 169   1        LCD_WR_REG(0xE1);     //negative gamma
 170   1        LCD_WR_DATA8(0x0A);   
 171   1        LCD_WR_DATA8(0x0D);   
 172   1        LCD_WR_DATA8(0x08);   
 173   1        LCD_WR_DATA8(0x07);   
 174   1        LCD_WR_DATA8(0x0F);   
 175   1        LCD_WR_DATA8(0x07);   
 176   1        LCD_WR_DATA8(0x02);   
 177   1        LCD_WR_DATA8(0x07);   
 178   1        LCD_WR_DATA8(0x09);   
C51 COMPILER V9.60.7.0   SPI                                                               02/08/2023 19:28:49 PAGE 4   

 179   1        LCD_WR_DATA8(0x0F);   
 180   1        LCD_WR_DATA8(0x25);   
 181   1        LCD_WR_DATA8(0x35);   
 182   1        LCD_WR_DATA8(0x00);   
 183   1        LCD_WR_DATA8(0x09);   
 184   1        LCD_WR_DATA8(0x04);   
 185   1        LCD_WR_DATA8(0x10);
 186   1           
 187   1        LCD_WR_REG(0xFC);    
 188   1        LCD_WR_DATA8(0x80);  
 189   1          
 190   1        LCD_WR_REG(0x3A);     
 191   1        LCD_WR_DATA8(0x05);   
 192   1        LCD_WR_REG(0x36);
 193   1        if(USE_HORIZONTAL==0)LCD_WR_DATA8(0x08);
 194   1        else if(USE_HORIZONTAL==1)LCD_WR_DATA8(0xC8);
 195   1        else if(USE_HORIZONTAL==2)LCD_WR_DATA8(0x78);
 196   1        else LCD_WR_DATA8(0xA8);   
 197   1        LCD_WR_REG(0x21);     //Display inversion
 198   1        LCD_WR_REG(0x29);     //Display on
 199   1        LCD_WR_REG(0x2A);     //Set Column Address
 200   1        LCD_WR_DATA8(0x00);   
 201   1        LCD_WR_DATA8(0x1A);  //26  
 202   1        LCD_WR_DATA8(0x00);   
 203   1        LCD_WR_DATA8(0x69);   //105 
 204   1        LCD_WR_REG(0x2B);     //Set Page Address
 205   1        LCD_WR_DATA8(0x00);   
 206   1        LCD_WR_DATA8(0x01);    //1
 207   1        LCD_WR_DATA8(0x00);   
 208   1        LCD_WR_DATA8(0xA0);    //160
 209   1        LCD_WR_REG(0x2C); 
 210   1      }
 211          
 212          void LCD_Fill(uint16_t xsta,uint16_t ysta,uint16_t xend,uint16_t yend,uint16_t color)
 213          {          
 214   1        uint16_t i,j; 
 215   1        LCD_Address_Set(xsta,ysta,xend-1,yend-1);//设置显示范围
 216   1        for(i=ysta;i<yend;i++)
 217   1        {                               
 218   2          for(j=xsta;j<xend;j++)
 219   2          {
 220   3            LCD_WR_DATA(color);
 221   3          }
 222   2        }                   
 223   1      }
 224          
 225          void LCD_DrawPoint(uint16_t x,uint16_t y,uint16_t color)
 226          {
 227   1        LCD_Address_Set(x,y,x,y);//设置光标位置 
 228   1        LCD_WR_DATA(color);
 229   1      } 
 230          
 231          //void LCD_ShowChar(uint16_t x,uint16_t y,uint8_t num,uint16_t fc,uint16_t bc,uint8_t sizey,uint8_t mode)
 232          //{
 233          //  uint8_t temp,sizex,t,m=0;
 234          //  uint16_t i,TypefaceNum;//一个字符所占字节大小
 235          //  uint16_t x0=x;
 236          //  sizex=sizey/2;
 237          //  TypefaceNum=(sizex/8+((sizex%8)?1:0))*sizey;
 238          //  num=num-' ';    //得到偏移后的值
 239          //  LCD_Address_Set(x,y,x+sizex-1,y+sizey-1);  //设置光标位置 
 240          //  for(i=0;i<TypefaceNum;i++)
C51 COMPILER V9.60.7.0   SPI                                                               02/08/2023 19:28:49 PAGE 5   

 241          //  { 
 242          ////    if(sizey==12)temp=ascii_1206[num][i];          //调用6x12字体
 243          ////    else if(sizey==16)temp=ascii_1608[num][i];     //调用8x16字体
 244          ////    else if(sizey==24)temp=ascii_2412[num][i];     //调用12x24字体
 245          ////    else if(sizey==32)temp=ascii_3216[num][i];     //调用16x32字体
 246          ////    else return;
 247          //    temp=ascii_1608[num][i];
 248          //    for(t=0;t<8;t++)
 249          //    {
 250          //      if(!mode)//非叠加模式
 251          //      {
 252          //        if(temp&(0x01<<t))LCD_WR_DATA(fc);
 253          //        else LCD_WR_DATA(bc);
 254          //        m++;
 255          //        if(m%sizex==0)
 256          //        {
 257          //          m=0;
 258          //          break;
 259          //        }
 260          //      }
 261          //      else//叠加模式
 262          //      {
 263          //        if(temp&(0x01<<t))LCD_DrawPoint(x,y,fc);//画一个点
 264          //        x++;
 265          //        if((x-x0)==sizex)
 266          //        {
 267          //          x=x0;
 268          //          y++;
 269          //          break;
 270          //        }
 271          //      }
 272          //    }
 273          //  }         
 274          //}
 275          
 276          //void LCD_ShowString(uint16_t x,uint16_t y,const uint8_t *p,uint16_t fc,uint16_t bc,uint8_t sizey,uint8_t
             - mode)
 277          //{         
 278          //  while(*p!='\0')
 279          //  {       
 280          //    LCD_ShowChar(x,y,*p,fc,bc,sizey,mode);
 281          //    x+=sizey/2;
 282          //    p++;
 283          //  }  
 284          //}
*** WARNING C294 IN LINE 66 OF spi.c: unreachable code
*** WARNING C294 IN LINE 76 OF spi.c: unreachable code
*** WARNING C294 IN LINE 96 OF spi.c: unreachable code
*** WARNING C294 IN LINE 196 OF spi.c: unreachable code


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    683    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      20
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  4 WARNING(S),  0 ERROR(S)
